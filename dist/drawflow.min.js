(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Drawflow"] = factory();
	else
		root["Drawflow"] = factory();
})((typeof self !== 'undefined' ? self : this), function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/drawflow.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/drawflow.js":
/*!*************************!*\
  !*** ./src/drawflow.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Drawflow; });\nclass Drawflow {\n    constructor(container, render = null, parent = null) {\n        this.events = {};\n        this.container = container;\n        this.precanvas = null;\n        this.nodeId = 1;\n        this.ele_selected = null;\n        this.node_selected = null;\n        this.drag = false;\n        this.reroute = false;\n        this.reroute_fix_curvature = false;\n        this.curvature = 0.5;\n        this.reroute_curvature_start_end = 0.5;\n        this.reroute_curvature = 0.5;\n        this.reroute_width = 6;\n        this.drag_point = false;\n        this.editor_selected = false;\n        this.connection = false;\n        this.connection_ele = null;\n        this.connection_selected = null;\n        this.canvas_x = 0;\n        this.canvas_y = 0;\n        this.pos_x = 0;\n        this.pos_x_start = 0;\n        this.pos_y = 0;\n        this.pos_y_start = 0;\n        this.mouse_x = 0;\n        this.mouse_y = 0;\n        this.line_path = 5;\n        this.first_click = null;\n        this.draggable_inputs = true;\n        this.useuuid = false;\n        this.parent = parent;\n\n        this.noderegister = {};\n        this.render = render;\n        this.drawflow = {\n            \"drawflow\": {\n                \"Home\": {\n                    \"data\": {}\n                }\n            }\n        };\n        // Configurable options\n        this.module = 'Home';\n        this.editor_mode = 'edit';\n        this.zoom = 1;\n        this.zoom_max = 1.6;\n        this.zoom_min = 0.5;\n        this.zoom_value = 0.1;\n        this.zoom_last_value = 1;\n\n        // Mobile\n        this.evCache = new Array();\n        this.prevDiff = -1;\n    }\n\n    start() {\n        // console.info(\"Start Drawflow!!\");\n        this.container.classList.add(\"parent-drawflow\");\n        this.container.tabIndex = 0;\n        this.precanvas = document.createElement('div');\n        this.precanvas.classList.add(\"drawflow\");\n        this.container.appendChild(this.precanvas);\n\n        /* Mouse and Touch Actions */\n        this.container.addEventListener('mouseup', this.dragEnd.bind(this));\n        this.container.addEventListener('mousemove', this.position.bind(this));\n        this.container.addEventListener('mousedown', this.click.bind(this));\n\n        this.container.addEventListener('touchend', this.dragEnd.bind(this));\n        this.container.addEventListener('touchmove', this.position.bind(this));\n        this.container.addEventListener('touchstart', this.click.bind(this));\n\n        /* Context Menu */\n        this.container.addEventListener('contextmenu', this.contextmenu.bind(this));\n        /* Delete */\n        this.container.addEventListener('keydown', this.key.bind(this));\n\n        /* Zoom Mouse */\n        this.container.addEventListener('wheel', this.zoom_enter.bind(this));\n        /* Update data Nodes */\n        this.container.addEventListener('input', this.updateNodeValue.bind(this));\n\n        this.container.addEventListener('dblclick', this.dblclick.bind(this));\n        /* Mobile zoom */\n        this.container.onpointerdown = this.pointerdown_handler.bind(this);\n        this.container.onpointermove = this.pointermove_handler.bind(this);\n        this.container.onpointerup = this.pointerup_handler.bind(this);\n        this.container.onpointercancel = this.pointerup_handler.bind(this);\n        this.container.onpointerout = this.pointerup_handler.bind(this);\n        this.container.onpointerleave = this.pointerup_handler.bind(this);\n\n        this.load();\n    }\n\n    /* Mobile zoom */\n    pointerdown_handler(ev) {\n        this.evCache.push(ev);\n    }\n\n    pointermove_handler(ev) {\n        for (var i = 0; i < this.evCache.length; i++) {\n            if (ev.pointerId == this.evCache[i].pointerId) {\n                this.evCache[i] = ev;\n                break;\n            }\n        }\n\n        if (this.evCache.length == 2) {\n            // Calculate the distance between the two pointers\n            var curDiff = Math.abs(this.evCache[0].clientX - this.evCache[1].clientX);\n\n            if (this.prevDiff > 100) {\n                if (curDiff > this.prevDiff) {\n                    // The distance between the two pointers has increased\n\n                    this.zoom_in();\n                }\n                if (curDiff < this.prevDiff) {\n                    // The distance between the two pointers has decreased\n                    this.zoom_out();\n                }\n            }\n            this.prevDiff = curDiff;\n        }\n    }\n\n    pointerup_handler(ev) {\n        this.remove_event(ev);\n        if (this.evCache.length < 2) {\n            this.prevDiff = -1;\n        }\n    }\n    remove_event(ev) {\n        // Remove this event from the target's cache\n        for (var i = 0; i < this.evCache.length; i++) {\n            if (this.evCache[i].pointerId == ev.pointerId) {\n                this.evCache.splice(i, 1);\n                break;\n            }\n        }\n    }\n    /* End Mobile Zoom */\n    load() {\n        for (var key in this.drawflow.drawflow[this.module].data) {\n            this.addNodeImport(this.drawflow.drawflow[this.module].data[key], this.precanvas);\n        }\n\n        if (this.reroute) {\n            for (var key in this.drawflow.drawflow[this.module].data) {\n                this.addRerouteImport(this.drawflow.drawflow[this.module].data[key]);\n            }\n        }\n\n        for (var key in this.drawflow.drawflow[this.module].data) {\n            this.updateConnectionNodes('node-' + key);\n        }\n\n        const editor = this.drawflow.drawflow;\n        let number = 1;\n        Object.keys(editor).map(function(moduleName, index) {\n            Object.keys(editor[moduleName].data).map(function(id, index2) {\n                if (parseInt(id) >= number) {\n                    number = parseInt(id) + 1;\n                }\n            });\n        });\n        this.nodeId = number;\n    }\n\n    removeReouteConnectionSelected() {\n        this.dispatch('connectionUnselected', true);\n        if (this.reroute_fix_curvature) {\n            this.connection_selected.parentElement.querySelectorAll(\".main-path\").forEach((item, i) => {\n                item.classList.remove(\"selected\");\n            });\n        }\n    }\n\n    click(e) {\n        this.dispatch('click', e);\n        \n        console.log('this.editor_mode', this.editor_mode);\n\n        if (this.editor_mode === 'fixed') {\n            //return false;\n            e.preventDefault();\n            if (e.target.classList[0] === 'parent-drawflow' || e.target.classList[0] === 'drawflow') {\n                this.ele_selected = e.target.closest(\".parent-drawflow\");\n            } else {\n                return false;\n            }\n        } else if (this.editor_mode === 'view') {\n            if (e.target.closest(\".drawflow\") != null || e.target.matches('.parent-drawflow')) {\n                this.ele_selected = e.target.closest(\".parent-drawflow\");\n                e.preventDefault();\n            }\n        } else {\n            this.first_click = e.target;\n            this.ele_selected = e.target;\n            if (e.button === 0) {\n                this.contextmenuDel();\n            }\n\n            if (e.target.closest(\".node-content\") != null) {\n                this.ele_selected = e.target.closest(\".node-content\").parentElement;\n            }\n        }\n        switch (this.ele_selected.classList[0]) {\n            case 'drawflow-node':\n                if (this.node_selected != null) {\n                    this.node_selected.classList.remove(\"selected\");\n                    if (this.node_selected != this.ele_selected) {\n                        this.dispatch('nodeUnselected', true);\n                    }\n                }\n                if (this.connection_selected != null) {\n                    this.connection_selected.classList.remove(\"selected\");\n                    this.removeReouteConnectionSelected();\n                    this.connection_selected = null;\n                }\n                if (this.node_selected != this.ele_selected) {\n                    this.dispatch('nodeSelected', this.ele_selected.id.slice(5));\n                }\n                this.node_selected = this.ele_selected;\n                this.node_selected.classList.add(\"selected\");\n                if (!this.draggable_inputs) {\n                    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && e.target.tagName !== 'SELECT' && e.target.hasAttribute('contenteditable') !== true) {\n                        this.drag = true;\n                    }\n                } else {\n                    if (e.target.tagName !== 'SELECT') {\n                        this.drag = true;\n                    }\n                }\n                break;\n            case 'output':\n                this.connection = true;\n                if (this.node_selected != null) {\n                    this.node_selected.classList.remove(\"selected\");\n                    this.node_selected = null;\n                    this.dispatch('nodeUnselected', true);\n                }\n                if (this.connection_selected != null) {\n                    this.connection_selected.classList.remove(\"selected\");\n                    this.removeReouteConnectionSelected();\n                    this.connection_selected = null;\n                }\n                this.drawConnection(e.target);\n                break;\n            case 'parent-drawflow':\n                if (this.node_selected != null) {\n                    this.node_selected.classList.remove(\"selected\");\n                    this.node_selected = null;\n                    this.dispatch('nodeUnselected', true);\n                }\n                if (this.connection_selected != null) {\n                    this.connection_selected.classList.remove(\"selected\");\n                    this.removeReouteConnectionSelected();\n                    this.connection_selected = null;\n                }\n                this.editor_selected = true;\n                break;\n            case 'drawflow':\n                if (this.node_selected != null) {\n                    this.node_selected.classList.remove(\"selected\");\n                    this.node_selected = null;\n                    this.dispatch('nodeUnselected', true);\n                }\n                if (this.connection_selected != null) {\n                    this.connection_selected.classList.remove(\"selected\");\n                    this.removeReouteConnectionSelected();\n                    this.connection_selected = null;\n                }\n                this.editor_selected = true;\n                break;\n            case 'main-path':\n                if (this.node_selected != null) {\n                    this.node_selected.classList.remove(\"selected\");\n                    this.node_selected = null;\n                    this.dispatch('nodeUnselected', true);\n                }\n                if (this.connection_selected != null) {\n                    this.connection_selected.classList.remove(\"selected\");\n                    this.removeReouteConnectionSelected();\n                    this.connection_selected = null;\n                }\n                this.connection_selected = this.ele_selected;\n                this.connection_selected.classList.add(\"selected\");\n                const listclassConnection = this.connection_selected.parentElement.classList;\n                if (listclassConnection.length > 1) {\n                    // https://github.com/jerosoler/Drawflow/issues/446 HACK fix\n                    this.container.focus();\n                    this.dispatch('connectionSelected', {\n                        output_id: listclassConnection[2].slice(14),\n                        input_id: listclassConnection[1].slice(13),\n                        output_class: listclassConnection[3],\n                        input_class: listclassConnection[4]\n                    });\n                    if (this.reroute_fix_curvature) {\n                        this.connection_selected.parentElement.querySelectorAll(\".main-path\").forEach((item, i) => {\n                            item.classList.add(\"selected\");\n                        });\n                    }\n                }\n                break;\n            case 'point':\n                this.drag_point = true;\n                this.ele_selected.classList.add(\"selected\");\n                break;\n            case 'drawflow-delete':\n                if (this.node_selected) {\n                    this.removeNodeId(this.node_selected.id);\n                }\n\n                if (this.connection_selected) {\n                    this.removeConnection();\n                }\n\n                if (this.node_selected != null) {\n                    this.node_selected.classList.remove(\"selected\");\n                    this.node_selected = null;\n                    this.dispatch('nodeUnselected', true);\n                }\n                if (this.connection_selected != null) {\n                    this.connection_selected.classList.remove(\"selected\");\n                    this.removeReouteConnectionSelected();\n                    this.connection_selected = null;\n                }\n\n                break;\n            default:\n        }\n        if (e.type === \"touchstart\") {\n            this.pos_x = e.touches[0].clientX;\n            this.pos_x_start = e.touches[0].clientX;\n            this.pos_y = e.touches[0].clientY;\n            this.pos_y_start = e.touches[0].clientY;\n            this.mouse_x = e.touches[0].clientX;\n            this.mouse_y = e.touches[0].clientY;\n        } else {\n            this.pos_x = e.clientX;\n            this.pos_x_start = e.clientX;\n            this.pos_y = e.clientY;\n            this.pos_y_start = e.clientY;\n        }\n        if (['input', 'output', 'main-path'].includes(this.ele_selected.classList[0])) {\n            e.preventDefault();\n        }\n        this.dispatch('clickEnd', e);\n    }\n\n    position(e) {\n        if (e.type === \"touchmove\") {\n            var e_pos_x = e.touches[0].clientX;\n            var e_pos_y = e.touches[0].clientY;\n        } else {\n            var e_pos_x = e.clientX;\n            var e_pos_y = e.clientY;\n        }\n\n\n        if (this.connection) {\n            this.updateConnection(e_pos_x, e_pos_y);\n        }\n        if (this.editor_selected) {\n            x = this.canvas_x + (-(this.pos_x - e_pos_x))\n            y = this.canvas_y + (-(this.pos_y - e_pos_y))\n            this.dispatch('translate', {\n                x: x,\n                y: y\n            });\n            this.precanvas.style.transform = \"translate(\" + x + \"px, \" + y + \"px) scale(\" + this.zoom + \")\";\n        }\n        if (this.drag) {\n            e.preventDefault();\n            var x = (this.pos_x - e_pos_x) * this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom);\n            var y = (this.pos_y - e_pos_y) * this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom);\n            this.pos_x = e_pos_x;\n            this.pos_y = e_pos_y;\n\n            this.ele_selected.style.top = (this.ele_selected.offsetTop - y) + \"px\";\n            this.ele_selected.style.left = (this.ele_selected.offsetLeft - x) + \"px\";\n\n            this.drawflow.drawflow[this.module].data[this.ele_selected.id.slice(5)].pos_x = (this.ele_selected.offsetLeft - x);\n            this.drawflow.drawflow[this.module].data[this.ele_selected.id.slice(5)].pos_y = (this.ele_selected.offsetTop - y);\n\n            this.updateConnectionNodes(this.ele_selected.id)\n        }\n\n        if (this.drag_point) {\n\n            var x = (this.pos_x - e_pos_x) * this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom);\n            var y = (this.pos_y - e_pos_y) * this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom);\n            this.pos_x = e_pos_x;\n            this.pos_y = e_pos_y;\n\n            var pos_x = this.pos_x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) - (this.precanvas.getBoundingClientRect().x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)));\n            var pos_y = this.pos_y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) - (this.precanvas.getBoundingClientRect().y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)));\n\n            this.ele_selected.setAttributeNS(null, 'cx', pos_x);\n            this.ele_selected.setAttributeNS(null, 'cy', pos_y);\n\n            const nodeUpdate = this.ele_selected.parentElement.classList[2].slice(9);\n            const nodeUpdateIn = this.ele_selected.parentElement.classList[1].slice(13);\n            const output_class = this.ele_selected.parentElement.classList[3];\n            const input_class = this.ele_selected.parentElement.classList[4];\n\n            let numberPointPosition = Array.from(this.ele_selected.parentElement.children).indexOf(this.ele_selected) - 1;\n\n            if (this.reroute_fix_curvature) {\n                const numberMainPath = this.ele_selected.parentElement.querySelectorAll(\".main-path\").length - 1;\n                numberPointPosition -= numberMainPath;\n                if (numberPointPosition < 0) {\n                    numberPointPosition = 0;\n                }\n            }\n\n            const nodeId = nodeUpdate.slice(5);\n            const searchConnection = this.drawflow.drawflow[this.module].data[nodeId].outputs[output_class].connections.findIndex(function(item, i) {\n                return item.node === nodeUpdateIn && item.output === input_class;\n            });\n\n            this.drawflow.drawflow[this.module].data[nodeId].outputs[output_class].connections[searchConnection].points[numberPointPosition] = {\n                pos_x: pos_x,\n                pos_y: pos_y\n            };\n\n            const parentSelected = this.ele_selected.parentElement.classList[2].slice(9);\n\n            this.updateConnectionNodes(parentSelected);\n        }\n\n        if (e.type === \"touchmove\") {\n            this.mouse_x = e_pos_x;\n            this.mouse_y = e_pos_y;\n        }\n        this.dispatch('mouseMove', {\n            x: e_pos_x,\n            y: e_pos_y\n        });\n    }\n\n    dragEnd(e) {\n        if (e.type === \"touchend\") {\n            var e_pos_x = this.mouse_x;\n            var e_pos_y = this.mouse_y;\n            var ele_last = document.elementFromPoint(e_pos_x, e_pos_y);\n        } else {\n            var e_pos_x = e.clientX;\n            var e_pos_y = e.clientY;\n            var ele_last = e.target;\n        }\n\n        if (this.drag) {\n            if (this.pos_x_start != e_pos_x || this.pos_y_start != e_pos_y) {\n                this.dispatch('nodeMoved', this.ele_selected.id.slice(5));\n            }\n        }\n\n        if (this.drag_point) {\n            this.ele_selected.classList.remove(\"selected\");\n            if (this.pos_x_start != e_pos_x || this.pos_y_start != e_pos_y) {\n                this.dispatch('rerouteMoved', this.ele_selected.parentElement.classList[2].slice(14));\n            }\n        }\n\n        if (this.editor_selected) {\n            this.canvas_x = this.canvas_x + (-(this.pos_x - e_pos_x));\n            this.canvas_y = this.canvas_y + (-(this.pos_y - e_pos_y));\n            this.editor_selected = false;\n        }\n\n        if (this.connection === true) {\n            if (ele_last.classList[0] === 'input') {\n                // Fix connection;\n                let input_id = ele_last.parentElement.parentElement.id;\n                let input_class = ele_last.classList[1];\n\n                let output_id = this.ele_selected.parentElement.parentElement.id;\n                let output_class = this.ele_selected.classList[1];\n\n                if (output_id !== input_id && input_class !== false) {\n\n                    if (this.container.querySelectorAll('.connection.node_in_' + input_id + '.node_out_' + output_id + '.' + output_class + '.' + input_class).length === 0) {\n                        // Conection not exist save connection\n\n                        this.connection_ele.classList.add(\"node_in_\" + input_id);\n                        this.connection_ele.classList.add(\"node_out_\" + output_id);\n                        this.connection_ele.classList.add(output_class);\n                        this.connection_ele.classList.add(input_class);\n                        let id_input = input_id.slice(5);\n                        let id_output = output_id.slice(5);\n                        console.log(\"Called inside\");\n                        console.log(this.drawflow);\n\n                        // Check type before connecting\n                        let from = this.drawflow.drawflow[this.module].data[id_output].outputs[output_class];\n                        let to = this.drawflow.drawflow[this.module].data[id_input].inputs[input_class];\n                        \n                        if(from['type'] != to['type']) {\n                            this.connection_ele.remove();\n                            toastr.error(`Datatype between <b>${from['title']} (${from['type']}) != ${to['title']} (${to['type']})</b>`);\n                        } else {\n\n                            this.drawflow.drawflow[this.module].data[id_output].outputs[output_class].connections.push({\n                                \"node\": id_input,\n                                \"output\": input_class\n                            });\n                            this.drawflow.drawflow[this.module].data[id_input].inputs[input_class].connections.push({\n                                \"node\": id_output,\n                                \"input\": output_class\n                            });\n\n                            this.updateConnectionNodes('node-' + id_output);\n                            this.updateConnectionNodes('node-' + id_input);\n                            this.dispatch('connectionCreated', {\n                                output_id: id_output,\n                                input_id: id_input,\n                                output_class: output_class,\n                                input_class: input_class\n                            });\n                        }\n                        console.log(from, to);\n                    } else {\n                        this.dispatch('connectionCancel', true);\n                        this.connection_ele.remove();\n                    }\n\n                    this.connection_ele = null;\n                } else {\n                    // Connection exists Remove Connection;\n                    this.dispatch('connectionCancel', true);\n                    this.connection_ele.remove();\n                    this.connection_ele = null;\n                }\n\n            } else {\n                // Remove Connection;\n                this.dispatch('connectionCancel', true);\n                this.connection_ele.remove();\n                this.connection_ele = null;\n            }\n        }\n\n        this.drag = false;\n        this.drag_point = false;\n        this.connection = false;\n        this.ele_selected = null;\n        this.editor_selected = false;\n\n        this.dispatch('mouseUp', e);\n    }\n    contextmenu(e) {\n        this.dispatch('contextmenu', e);\n        e.preventDefault();\n        // Disable contextmenu or mouse right click\n        // if (this.editor_mode === 'fixed' || this.editor_mode === 'view') {\n        //     return false;\n        // }\n        // if (this.precanvas.getElementsByClassName(\"drawflow-delete\").length) {\n        //     this.precanvas.getElementsByClassName(\"drawflow-delete\")[0].remove()\n        // };\n        // if (this.node_selected || this.connection_selected) {\n        //     var deletebox = document.createElement('div');\n        //     deletebox.classList.add(\"drawflow-delete\");\n        //     deletebox.innerHTML = \"x\";\n        //     if (this.node_selected) {\n        //         this.node_selected.appendChild(deletebox);\n\n        //     }\n        //     if (this.connection_selected && (this.connection_selected.parentElement.classList.length > 1)) {\n        //         deletebox.style.top = e.clientY * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) - (this.precanvas.getBoundingClientRect().y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom))) + \"px\";\n        //         deletebox.style.left = e.clientX * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) - (this.precanvas.getBoundingClientRect().x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom))) + \"px\";\n\n        //         this.precanvas.appendChild(deletebox);\n\n        //     }\n\n        // }\n\n    }\n    contextmenuDel() {\n        if (this.precanvas.getElementsByClassName(\"drawflow-delete\").length) {\n            this.precanvas.getElementsByClassName(\"drawflow-delete\")[0].remove()\n        };\n    }\n\n    key(e) {\n        this.dispatch('keydown', e);\n        console.log(this.connection_selected, 'helllo world');\n        if (this.editor_mode === 'fixed' || this.editor_mode === 'view') {\n            return false;\n        }\n        if (e.key === 'Delete' || (e.key === 'Backspace')) {\n            if (this.node_selected != null) {\n                if (this.first_click.tagName !== 'INPUT' && this.first_click.tagName !== 'TEXTAREA' && this.first_click.hasAttribute('contenteditable') !== true) {\n                    this.removeNodeId(this.node_selected.id);\n                }\n            }\n            if (this.connection_selected != null) {\n                this.removeConnection();\n            }\n        }\n    }\n\n    zoom_enter(event, delta) {\n        if (event.ctrlKey) {\n            event.preventDefault()\n            if (event.deltaY > 0) {\n                // Zoom Out\n                this.zoom_out();\n            } else {\n                // Zoom In\n                this.zoom_in();\n            }\n        }\n    }\n    zoom_refresh() {\n        this.dispatch('zoom', this.zoom);\n        this.canvas_x = (this.canvas_x / this.zoom_last_value) * this.zoom;\n        this.canvas_y = (this.canvas_y / this.zoom_last_value) * this.zoom;\n        this.zoom_last_value = this.zoom;\n        this.precanvas.style.transform = \"translate(\" + this.canvas_x + \"px, \" + this.canvas_y + \"px) scale(\" + this.zoom + \")\";\n    }\n    zoom_in() {\n        if (this.zoom < this.zoom_max) {\n            this.zoom += this.zoom_value;\n            this.zoom_refresh();\n        }\n    }\n    zoom_out() {\n        if (this.zoom > this.zoom_min) {\n            this.zoom -= this.zoom_value;\n            this.zoom_refresh();\n        }\n    }\n    zoom_reset() {\n        if (this.zoom != 1) {\n            this.zoom = 1;\n            this.zoom_refresh();\n        }\n    }\n\n    createCurvature(start_pos_x, start_pos_y, end_pos_x, end_pos_y, curvature_value, type) {\n        var line_x = start_pos_x;\n        var line_y = start_pos_y;\n        var x = end_pos_x;\n        var y = end_pos_y;\n        var curvature = curvature_value;\n        //type openclose open close other\n        switch (type) {\n            case 'open':\n                if (start_pos_x >= end_pos_x) {\n                    var hx1 = line_x + Math.abs(x - line_x) * curvature;\n                    var hx2 = x - Math.abs(x - line_x) * (curvature * -1);\n                } else {\n                    var hx1 = line_x + Math.abs(x - line_x) * curvature;\n                    var hx2 = x - Math.abs(x - line_x) * curvature;\n                }\n                return ' M ' + line_x + ' ' + line_y + ' C ' + hx1 + ' ' + line_y + ' ' + hx2 + ' ' + y + ' ' + x + '  ' + y;\n\n                break\n            case 'close':\n                if (start_pos_x >= end_pos_x) {\n                    var hx1 = line_x + Math.abs(x - line_x) * (curvature * -1);\n                    var hx2 = x - Math.abs(x - line_x) * curvature;\n                } else {\n                    var hx1 = line_x + Math.abs(x - line_x) * curvature;\n                    var hx2 = x - Math.abs(x - line_x) * curvature;\n                }\n                return ' M ' + line_x + ' ' + line_y + ' C ' + hx1 + ' ' + line_y + ' ' + hx2 + ' ' + y + ' ' + x + '  ' + y;\n                break;\n            case 'other':\n                if (start_pos_x >= end_pos_x) {\n                    var hx1 = line_x + Math.abs(x - line_x) * (curvature * -1);\n                    var hx2 = x - Math.abs(x - line_x) * (curvature * -1);\n                } else {\n                    var hx1 = line_x + Math.abs(x - line_x) * curvature;\n                    var hx2 = x - Math.abs(x - line_x) * curvature;\n                }\n                return ' M ' + line_x + ' ' + line_y + ' C ' + hx1 + ' ' + line_y + ' ' + hx2 + ' ' + y + ' ' + x + '  ' + y;\n                break;\n            default:\n\n                var hx1 = line_x + Math.abs(x - line_x) * curvature;\n                var hx2 = x - Math.abs(x - line_x) * curvature;\n\n                return ' M ' + line_x + ' ' + line_y + ' C ' + hx1 + ' ' + line_y + ' ' + hx2 + ' ' + y + ' ' + x + '  ' + y;\n        }\n\n    }\n\n    drawConnection(ele) {\n        var connection = document.createElementNS('http://www.w3.org/2000/svg', \"svg\");\n        this.connection_ele = connection;\n        var path = document.createElementNS('http://www.w3.org/2000/svg', \"path\");\n        path.classList.add(\"main-path\");\n        path.setAttributeNS(null, 'd', '');\n        // path.innerHTML = 'a';\n        connection.classList.add(\"connection\");\n        connection.appendChild(path);\n        this.precanvas.appendChild(connection);\n        var id_output = ele.parentElement.parentElement.id.slice(5);\n        var output_class = ele.classList[1];\n        this.dispatch('connectionStart', {\n            output_id: id_output,\n            output_class: output_class\n        });\n\n    }\n\n    updateConnection(eX, eY) {\n        const precanvas = this.precanvas;\n        const zoom = this.zoom;\n        let precanvasWitdhZoom = precanvas.clientWidth / (precanvas.clientWidth * zoom);\n        precanvasWitdhZoom = precanvasWitdhZoom || 0;\n        let precanvasHeightZoom = precanvas.clientHeight / (precanvas.clientHeight * zoom);\n        precanvasHeightZoom = precanvasHeightZoom || 0;\n        var path = this.connection_ele.children[0];\n\n        var line_x = this.ele_selected.offsetWidth / 2 + (this.ele_selected.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom;\n        var line_y = this.ele_selected.offsetHeight / 2 + (this.ele_selected.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom;\n\n        var x = eX * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) - (this.precanvas.getBoundingClientRect().x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)));\n        var y = eY * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) - (this.precanvas.getBoundingClientRect().y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)));\n\n        var curvature = this.curvature;\n        var lineCurve = this.createCurvature(line_x, line_y, x, y, curvature, 'openclose');\n        path.setAttributeNS(null, 'd', lineCurve);\n\n    }\n\n    addConnection(id_output, id_input, output_class, input_class) {\n        var nodeOneModule = this.getModuleFromNodeId(id_output);\n        var nodeTwoModule = this.getModuleFromNodeId(id_input);\n        if (nodeOneModule === nodeTwoModule) {\n\n            var dataNode = this.getNodeFromId(id_output);\n            var exist = false;\n            for (var checkOutput in dataNode.outputs[output_class].connections) {\n                var connectionSearch = dataNode.outputs[output_class].connections[checkOutput]\n                if (connectionSearch.node == id_input && connectionSearch.output == input_class) {\n                    exist = true;\n                }\n            }\n            // Check connection exist\n            if (exist === false) {\n                //Create Connection\n                this.drawflow.drawflow[nodeOneModule].data[id_output].outputs[output_class].connections.push({\n                    \"node\": id_input.toString(),\n                    \"output\": input_class\n                });\n                this.drawflow.drawflow[nodeOneModule].data[id_input].inputs[input_class].connections.push({\n                    \"node\": id_output.toString(),\n                    \"input\": output_class\n                });\n\n                if (this.module === nodeOneModule) {\n                    //Draw connection\n                    var connection = document.createElementNS('http://www.w3.org/2000/svg', \"svg\");\n                    var path = document.createElementNS('http://www.w3.org/2000/svg', \"path\");\n                    path.classList.add(\"main-path\");\n                    path.setAttributeNS(null, 'd', '');\n                    // path.innerHTML = 'a';\n                    connection.classList.add(\"connection\");\n                    connection.classList.add(\"node_in_node-\" + id_input);\n                    connection.classList.add(\"node_out_node-\" + id_output);\n                    connection.classList.add(output_class);\n                    connection.classList.add(input_class);\n                    connection.appendChild(path);\n                    this.precanvas.appendChild(connection);\n                    this.updateConnectionNodes('node-' + id_output);\n                    this.updateConnectionNodes('node-' + id_input);\n                }\n\n                this.dispatch('connectionCreated', {\n                    output_id: id_output,\n                    input_id: id_input,\n                    output_class: output_class,\n                    input_class: input_class\n                });\n            }\n        }\n    }\n\n    updateConnectionNodes(id) {\n\n        // Aquí nos quedamos;\n        const idSearch = 'node_in_' + id;\n        const idSearchOut = 'node_out_' + id;\n        var line_path = this.line_path / 2;\n        const container = this.container;\n        const precanvas = this.precanvas;\n        const curvature = this.curvature;\n        const createCurvature = this.createCurvature;\n        const reroute_curvature = this.reroute_curvature;\n        const reroute_curvature_start_end = this.reroute_curvature_start_end;\n        const reroute_fix_curvature = this.reroute_fix_curvature;\n        const rerouteWidth = this.reroute_width;\n        const zoom = this.zoom;\n        let precanvasWitdhZoom = precanvas.clientWidth / (precanvas.clientWidth * zoom);\n        precanvasWitdhZoom = precanvasWitdhZoom || 0;\n        let precanvasHeightZoom = precanvas.clientHeight / (precanvas.clientHeight * zoom);\n        precanvasHeightZoom = precanvasHeightZoom || 0;\n\n        const elemsOut = container.querySelectorAll(`.${idSearchOut}`);\n\n        Object.keys(elemsOut).map(function(item, index) {\n            if (elemsOut[item].querySelector('.point') === null) {\n\n                var elemtsearchId_out = container.querySelector(`#${id}`);\n\n                var id_search = elemsOut[item].classList[1].replace('node_in_', '');\n                var elemtsearchId = container.querySelector(`#${id_search}`);\n\n                var elemtsearch = elemtsearchId.querySelectorAll('.' + elemsOut[item].classList[4])[0]\n\n                var eX = elemtsearch.offsetWidth / 2 + (elemtsearch.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom;\n                var eY = elemtsearch.offsetHeight / 2 + (elemtsearch.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom;\n\n                var elemtsearchOut = elemtsearchId_out.querySelectorAll('.' + elemsOut[item].classList[3])[0]\n\n                var line_x = elemtsearchOut.offsetWidth / 2 + (elemtsearchOut.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom;\n                var line_y = elemtsearchOut.offsetHeight / 2 + (elemtsearchOut.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom;\n\n                var x = eX;\n                var y = eY;\n\n                const lineCurve = createCurvature(line_x, line_y, x, y, curvature, 'openclose');\n                elemsOut[item].children[0].setAttributeNS(null, 'd', lineCurve);\n            } else {\n                const points = elemsOut[item].querySelectorAll('.point');\n                let linecurve = '';\n                const reoute_fix = [];\n                points.forEach((item, i) => {\n                    if (i === 0 && ((points.length - 1) === 0)) {\n\n                        var elemtsearchId_out = container.querySelector(`#${id}`);\n                        var elemtsearch = item;\n\n                        var eX = (elemtsearch.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom + rerouteWidth;\n                        var eY = (elemtsearch.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom + rerouteWidth;\n\n                        var elemtsearchOut = elemtsearchId_out.querySelectorAll('.' + item.parentElement.classList[3])[0]\n                        var line_x = elemtsearchOut.offsetWidth / 2 + (elemtsearchOut.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom;\n                        var line_y = elemtsearchOut.offsetHeight / 2 + (elemtsearchOut.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom;\n                        var x = eX;\n                        var y = eY;\n\n                        var lineCurveSearch = createCurvature(line_x, line_y, x, y, reroute_curvature_start_end, 'open');\n                        linecurve += lineCurveSearch;\n                        reoute_fix.push(lineCurveSearch);\n\n                        var elemtsearchId_out = item;\n                        var id_search = item.parentElement.classList[1].replace('node_in_', '');\n                        var elemtsearchId = container.querySelector(`#${id_search}`);\n                        var elemtsearch = elemtsearchId.querySelectorAll('.' + item.parentElement.classList[4])[0]\n\n                        var elemtsearchIn = elemtsearchId.querySelectorAll('.' + item.parentElement.classList[4])[0]\n                        var eX = elemtsearchIn.offsetWidth / 2 + (elemtsearchIn.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom;\n                        var eY = elemtsearchIn.offsetHeight / 2 + (elemtsearchIn.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom;\n\n\n                        var line_x = (elemtsearchId_out.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom + rerouteWidth;\n                        var line_y = (elemtsearchId_out.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom + rerouteWidth;\n                        var x = eX;\n                        var y = eY;\n\n                        var lineCurveSearch = createCurvature(line_x, line_y, x, y, reroute_curvature_start_end, 'close');\n                        linecurve += lineCurveSearch;\n                        reoute_fix.push(lineCurveSearch);\n\n                    } else if (i === 0) {\n\n                        var elemtsearchId_out = container.querySelector(`#${id}`);\n                        var elemtsearch = item;\n\n                        var eX = (elemtsearch.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom + rerouteWidth;\n                        var eY = (elemtsearch.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom + rerouteWidth;\n\n                        var elemtsearchOut = elemtsearchId_out.querySelectorAll('.' + item.parentElement.classList[3])[0]\n                        var line_x = elemtsearchOut.offsetWidth / 2 + (elemtsearchOut.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom;\n                        var line_y = elemtsearchOut.offsetHeight / 2 + (elemtsearchOut.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom;\n\n                        var x = eX;\n                        var y = eY;\n\n                        var lineCurveSearch = createCurvature(line_x, line_y, x, y, reroute_curvature_start_end, 'open');\n                        linecurve += lineCurveSearch;\n                        reoute_fix.push(lineCurveSearch);\n\n                        // SECOND\n                        var elemtsearchId_out = item;\n                        var elemtsearch = points[i + 1];\n\n                        var eX = (elemtsearch.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom + rerouteWidth;\n                        var eY = (elemtsearch.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom + rerouteWidth;\n                        var line_x = (elemtsearchId_out.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom + rerouteWidth;\n                        var line_y = (elemtsearchId_out.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom + rerouteWidth;\n                        var x = eX;\n                        var y = eY;\n\n                        var lineCurveSearch = createCurvature(line_x, line_y, x, y, reroute_curvature, 'other');\n                        linecurve += lineCurveSearch;\n                        reoute_fix.push(lineCurveSearch);\n\n                    } else if (i === (points.length - 1)) {\n\n                        var elemtsearchId_out = item;\n\n                        var id_search = item.parentElement.classList[1].replace('node_in_', '');\n                        var elemtsearchId = container.querySelector(`#${id_search}`);\n                        var elemtsearch = elemtsearchId.querySelectorAll('.' + item.parentElement.classList[4])[0]\n\n                        var elemtsearchIn = elemtsearchId.querySelectorAll('.' + item.parentElement.classList[4])[0]\n                        var eX = elemtsearchIn.offsetWidth / 2 + (elemtsearchIn.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom;\n                        var eY = elemtsearchIn.offsetHeight / 2 + (elemtsearchIn.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom;\n                        var line_x = (elemtsearchId_out.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * (precanvas.clientWidth / (precanvas.clientWidth * zoom)) + rerouteWidth;\n                        var line_y = (elemtsearchId_out.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * (precanvas.clientHeight / (precanvas.clientHeight * zoom)) + rerouteWidth;\n                        var x = eX;\n                        var y = eY;\n\n                        var lineCurveSearch = createCurvature(line_x, line_y, x, y, reroute_curvature_start_end, 'close');\n                        linecurve += lineCurveSearch;\n                        reoute_fix.push(lineCurveSearch);\n\n                    } else {\n                        var elemtsearchId_out = item;\n                        var elemtsearch = points[i + 1];\n\n                        var eX = (elemtsearch.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * (precanvas.clientWidth / (precanvas.clientWidth * zoom)) + rerouteWidth;\n                        var eY = (elemtsearch.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * (precanvas.clientHeight / (precanvas.clientHeight * zoom)) + rerouteWidth;\n                        var line_x = (elemtsearchId_out.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * (precanvas.clientWidth / (precanvas.clientWidth * zoom)) + rerouteWidth;\n                        var line_y = (elemtsearchId_out.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * (precanvas.clientHeight / (precanvas.clientHeight * zoom)) + rerouteWidth;\n                        var x = eX;\n                        var y = eY;\n\n                        var lineCurveSearch = createCurvature(line_x, line_y, x, y, reroute_curvature, 'other');\n                        linecurve += lineCurveSearch;\n                        reoute_fix.push(lineCurveSearch);\n                    }\n\n                });\n                if (reroute_fix_curvature) {\n                    reoute_fix.forEach((itempath, i) => {\n                        elemsOut[item].children[i].setAttributeNS(null, 'd', itempath);\n                    });\n\n                } else {\n                    elemsOut[item].children[0].setAttributeNS(null, 'd', linecurve);\n                }\n\n            }\n        })\n\n        const elems = container.querySelectorAll(`.${idSearch}`);\n        Object.keys(elems).map(function(item, index) {\n\n            if (elems[item].querySelector('.point') === null) {\n                var elemtsearchId_in = container.querySelector(`#${id}`);\n\n                var id_search = elems[item].classList[2].replace('node_out_', '');\n                var elemtsearchId = container.querySelector(`#${id_search}`);\n                var elemtsearch = elemtsearchId.querySelectorAll('.' + elems[item].classList[3])[0]\n\n                var line_x = elemtsearch.offsetWidth / 2 + (elemtsearch.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom;\n                var line_y = elemtsearch.offsetHeight / 2 + (elemtsearch.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom;\n\n                var elemtsearchId_in = elemtsearchId_in.querySelectorAll('.' + elems[item].classList[4])[0]\n                var x = elemtsearchId_in.offsetWidth / 2 + (elemtsearchId_in.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom;\n                var y = elemtsearchId_in.offsetHeight / 2 + (elemtsearchId_in.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom;\n\n                const lineCurve = createCurvature(line_x, line_y, x, y, curvature, 'openclose');\n                elems[item].children[0].setAttributeNS(null, 'd', lineCurve);\n\n            } else {\n                const points = elems[item].querySelectorAll('.point');\n                let linecurve = '';\n                const reoute_fix = [];\n                points.forEach((item, i) => {\n                    if (i === 0 && ((points.length - 1) === 0)) {\n\n                        var elemtsearchId_out = container.querySelector(`#${id}`);\n                        var elemtsearch = item;\n\n                        var line_x = (elemtsearch.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom + rerouteWidth;\n                        var line_y = (elemtsearch.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom + rerouteWidth;\n\n                        var elemtsearchIn = elemtsearchId_out.querySelectorAll('.' + item.parentElement.classList[4])[0]\n                        var eX = elemtsearchIn.offsetWidth / 2 + (elemtsearchIn.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom;\n                        var eY = elemtsearchIn.offsetHeight / 2 + (elemtsearchIn.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom;\n\n                        var x = eX;\n                        var y = eY;\n\n                        var lineCurveSearch = createCurvature(line_x, line_y, x, y, reroute_curvature_start_end, 'close');\n                        linecurve += lineCurveSearch;\n                        reoute_fix.push(lineCurveSearch);\n\n                        var elemtsearchId_out = item;\n                        var id_search = item.parentElement.classList[2].replace('node_out_', '');\n                        var elemtsearchId = container.querySelector(`#${id_search}`);\n                        var elemtsearch = elemtsearchId.querySelectorAll('.' + item.parentElement.classList[3])[0]\n\n                        var elemtsearchOut = elemtsearchId.querySelectorAll('.' + item.parentElement.classList[3])[0]\n                        var line_x = elemtsearchOut.offsetWidth / 2 + (elemtsearchOut.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom;\n                        var line_y = elemtsearchOut.offsetHeight / 2 + (elemtsearchOut.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom;\n\n                        var eX = (elemtsearchId_out.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom + rerouteWidth;\n                        var eY = (elemtsearchId_out.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom + rerouteWidth;\n                        var x = eX;\n                        var y = eY;\n\n                        var lineCurveSearch = createCurvature(line_x, line_y, x, y, reroute_curvature_start_end, 'open');\n                        linecurve += lineCurveSearch;\n                        reoute_fix.push(lineCurveSearch);\n\n\n                    } else if (i === 0) {\n                        // FIRST\n                        var elemtsearchId_out = item;\n                        var id_search = item.parentElement.classList[2].replace('node_out_', '');\n                        var elemtsearchId = container.querySelector(`#${id_search}`);\n                        var elemtsearch = elemtsearchId.querySelectorAll('.' + item.parentElement.classList[3])[0]\n                        var elemtsearchOut = elemtsearchId.querySelectorAll('.' + item.parentElement.classList[3])[0]\n                        var line_x = elemtsearchOut.offsetWidth / 2 + (elemtsearchOut.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom;\n                        var line_y = elemtsearchOut.offsetHeight / 2 + (elemtsearchOut.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom;\n\n                        var eX = (elemtsearchId_out.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom + rerouteWidth;\n                        var eY = (elemtsearchId_out.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom + rerouteWidth;\n                        var x = eX;\n                        var y = eY;\n\n                        var lineCurveSearch = createCurvature(line_x, line_y, x, y, reroute_curvature_start_end, 'open');\n                        linecurve += lineCurveSearch;\n                        reoute_fix.push(lineCurveSearch);\n\n                        // SECOND\n                        var elemtsearchId_out = item;\n                        var elemtsearch = points[i + 1];\n\n                        var eX = (elemtsearch.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom + rerouteWidth;\n                        var eY = (elemtsearch.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom + rerouteWidth;\n                        var line_x = (elemtsearchId_out.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom + rerouteWidth;\n                        var line_y = (elemtsearchId_out.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom + rerouteWidth;\n                        var x = eX;\n                        var y = eY;\n\n                        var lineCurveSearch = createCurvature(line_x, line_y, x, y, reroute_curvature, 'other');\n                        linecurve += lineCurveSearch;\n                        reoute_fix.push(lineCurveSearch);\n\n                    } else if (i === (points.length - 1)) {\n\n                        var elemtsearchId_out = item;\n\n                        var id_search = item.parentElement.classList[1].replace('node_in_', '');\n                        var elemtsearchId = container.querySelector(`#${id_search}`);\n                        var elemtsearch = elemtsearchId.querySelectorAll('.' + item.parentElement.classList[4])[0]\n\n                        var elemtsearchIn = elemtsearchId.querySelectorAll('.' + item.parentElement.classList[4])[0]\n                        var eX = elemtsearchIn.offsetWidth / 2 + (elemtsearchIn.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom;\n                        var eY = elemtsearchIn.offsetHeight / 2 + (elemtsearchIn.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom;\n\n                        var line_x = (elemtsearchId_out.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom + rerouteWidth;\n                        var line_y = (elemtsearchId_out.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom + rerouteWidth;\n                        var x = eX;\n                        var y = eY;\n\n                        var lineCurveSearch = createCurvature(line_x, line_y, x, y, reroute_curvature_start_end, 'close');\n                        linecurve += lineCurveSearch;\n                        reoute_fix.push(lineCurveSearch);\n\n                    } else {\n\n                        var elemtsearchId_out = item;\n                        var elemtsearch = points[i + 1];\n\n                        var eX = (elemtsearch.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom + rerouteWidth;\n                        var eY = (elemtsearch.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom + rerouteWidth;\n                        var line_x = (elemtsearchId_out.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * precanvasWitdhZoom + rerouteWidth;\n                        var line_y = (elemtsearchId_out.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * precanvasHeightZoom + rerouteWidth;\n                        var x = eX;\n                        var y = eY;\n\n                        var lineCurveSearch = createCurvature(line_x, line_y, x, y, reroute_curvature, 'other');\n                        linecurve += lineCurveSearch;\n                        reoute_fix.push(lineCurveSearch);\n                    }\n\n                });\n                if (reroute_fix_curvature) {\n                    reoute_fix.forEach((itempath, i) => {\n                        elems[item].children[i].setAttributeNS(null, 'd', itempath);\n                    });\n\n                } else {\n                    elems[item].children[0].setAttributeNS(null, 'd', linecurve);\n                }\n\n            }\n        })\n    }\n\n    dblclick(e) {\n        if (this.connection_selected != null && this.reroute) {\n            this.createReroutePoint(this.connection_selected);\n        }\n\n        if (e.target.classList[0] === 'point') {\n            this.removeReroutePoint(e.target);\n        }\n    }\n\n    createReroutePoint(ele) {\n        this.connection_selected.classList.remove(\"selected\");\n        const nodeUpdate = this.connection_selected.parentElement.classList[2].slice(9);\n        const nodeUpdateIn = this.connection_selected.parentElement.classList[1].slice(13);\n        const output_class = this.connection_selected.parentElement.classList[3];\n        const input_class = this.connection_selected.parentElement.classList[4];\n        this.connection_selected = null;\n        const point = document.createElementNS('http://www.w3.org/2000/svg', \"circle\");\n        point.classList.add(\"point\");\n        var pos_x = this.pos_x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) - (this.precanvas.getBoundingClientRect().x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)));\n        var pos_y = this.pos_y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) - (this.precanvas.getBoundingClientRect().y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)));\n\n        point.setAttributeNS(null, 'cx', pos_x);\n        point.setAttributeNS(null, 'cy', pos_y);\n        point.setAttributeNS(null, 'r', this.reroute_width);\n\n        let position_add_array_point = 0;\n        if (this.reroute_fix_curvature) {\n\n            const numberPoints = ele.parentElement.querySelectorAll(\".main-path\").length;\n            var path = document.createElementNS('http://www.w3.org/2000/svg', \"path\");\n            path.classList.add(\"main-path\");\n            path.setAttributeNS(null, 'd', '');\n\n            ele.parentElement.insertBefore(path, ele.parentElement.children[numberPoints]);\n            if (numberPoints === 1) {\n                ele.parentElement.appendChild(point);\n            } else {\n                const search_point = Array.from(ele.parentElement.children).indexOf(ele)\n                position_add_array_point = search_point;\n                ele.parentElement.insertBefore(point, ele.parentElement.children[search_point + numberPoints + 1]);\n            }\n\n        } else {\n            ele.parentElement.appendChild(point);\n        }\n\n        const nodeId = nodeUpdate.slice(5);\n        const searchConnection = this.drawflow.drawflow[this.module].data[nodeId].outputs[output_class].connections.findIndex(function(item, i) {\n            return item.node === nodeUpdateIn && item.output === input_class;\n        });\n\n        if (this.drawflow.drawflow[this.module].data[nodeId].outputs[output_class].connections[searchConnection].points === undefined) {\n            this.drawflow.drawflow[this.module].data[nodeId].outputs[output_class].connections[searchConnection].points = [];\n        }\n\n        if (this.reroute_fix_curvature) {\n\n            if (position_add_array_point > 0 || this.drawflow.drawflow[this.module].data[nodeId].outputs[output_class].connections[searchConnection].points !== []) {\n                this.drawflow.drawflow[this.module].data[nodeId].outputs[output_class].connections[searchConnection].points.splice(position_add_array_point, 0, {\n                    pos_x: pos_x,\n                    pos_y: pos_y\n                });\n            } else {\n                this.drawflow.drawflow[this.module].data[nodeId].outputs[output_class].connections[searchConnection].points.push({\n                    pos_x: pos_x,\n                    pos_y: pos_y\n                });\n            }\n\n            ele.parentElement.querySelectorAll(\".main-path\").forEach((item, i) => {\n                item.classList.remove(\"selected\");\n            });\n\n        } else {\n            this.drawflow.drawflow[this.module].data[nodeId].outputs[output_class].connections[searchConnection].points.push({\n                pos_x: pos_x,\n                pos_y: pos_y\n            });\n        }\n\n        this.dispatch('addReroute', nodeId);\n        this.updateConnectionNodes(nodeUpdate);\n    }\n\n    removeReroutePoint(ele) {\n        const nodeUpdate = ele.parentElement.classList[2].slice(9)\n        const nodeUpdateIn = ele.parentElement.classList[1].slice(13);\n        const output_class = ele.parentElement.classList[3];\n        const input_class = ele.parentElement.classList[4];\n\n        let numberPointPosition = Array.from(ele.parentElement.children).indexOf(ele);\n        const nodeId = nodeUpdate.slice(5);\n        const searchConnection = this.drawflow.drawflow[this.module].data[nodeId].outputs[output_class].connections.findIndex(function(item, i) {\n            return item.node === nodeUpdateIn && item.output === input_class;\n        });\n\n        if (this.reroute_fix_curvature) {\n            const numberMainPath = ele.parentElement.querySelectorAll(\".main-path\").length\n            ele.parentElement.children[numberMainPath - 1].remove();\n            numberPointPosition -= numberMainPath;\n            if (numberPointPosition < 0) {\n                numberPointPosition = 0;\n            }\n        } else {\n            numberPointPosition--;\n        }\n        this.drawflow.drawflow[this.module].data[nodeId].outputs[output_class].connections[searchConnection].points.splice(numberPointPosition, 1);\n\n        ele.remove();\n        this.dispatch('removeReroute', nodeId);\n        this.updateConnectionNodes(nodeUpdate);\n    }\n\n    registerNode(name, html, props = null, options = null) {\n        this.noderegister[name] = {\n            html: html,\n            props: props,\n            options: options\n        };\n    }\n\n    getNodeFromId(id) {\n        var moduleName = this.getModuleFromNodeId(id);\n        return JSON.parse(JSON.stringify(this.drawflow.drawflow[moduleName].data[id]));\n    }\n    getNodesFromName(name) {\n        var nodes = [];\n        const editor = this.drawflow.drawflow;\n        Object.keys(editor).map(function(moduleName, index) {\n            for (var node in editor[moduleName].data) {\n                if (editor[moduleName].data[node].name == name) {\n                    nodes.push(editor[moduleName].data[node].id);\n                }\n            }\n        });\n        return nodes;\n    }\n\n    addNode(name, title_text, icon, inputs, outputs, ele_pos_x, ele_pos_y, classoverride=null, typenode=false) {\n        let jq_block_tmpl = $('#node-tmpl');\n        let context_data = {};\n        if (this.useuuid) {\n            var newNodeId = this.getUuid();\n        } else {\n            var newNodeId = this.nodeId;\n        }\n        context_data['nodeId'] = newNodeId;\n        if(classoverride == null) {\n            context_data['node_class_lst'] = '';\n        } else {\n            classoverride = 'private__'+classoverride;\n            context_data['node_class_lst'] = classoverride;\n        }\n        \n        let new_inputs = {};\n        for (const [key, value] of Object.entries(inputs)) {\n            value['connections'] = [];\n            new_inputs['private__'+key] = value;\n        }\n        context_data['inputs'] = new_inputs;\n\n        let new_outputs = {};\n        for (const [key, value] of Object.entries(outputs)) {\n            value['connections'] = [];\n            new_outputs['private__'+key] = value;\n        }\n        context_data['outputs'] = new_outputs;\n\n        let node = jq_block_tmpl.tmpl(context_data);\n        let node_content = node.find('.node-content');\n        let content_body = node_content.find('.body');\n        let content_title = node_content.find('.title');\n\n        content_title.find('.title_text').html(title_text);\n        content_title.find('.icon').html(icon);\n\n        let max_size = Math.max(Object.keys(inputs).length, Object.keys(outputs).length);\n\n        content_body.css({\n            'height': max_size*32+'px',\n        });\n\n        node.css({\n            'top': ele_pos_y + \"px\",\n            'left': ele_pos_x + \"px\"\n        });\n\n        node.appendTo(this.precanvas)\n\n        var json = {\n            id: newNodeId,\n            name: name,\n            class: classoverride,\n            typenode: typenode,\n            inputs: new_inputs,\n            outputs: new_outputs,\n            pos_x: ele_pos_x,\n            pos_y: ele_pos_y,\n        }\n        this.drawflow.drawflow[this.module].data[newNodeId] = json;\n        this.dispatch('nodeCreated', newNodeId);\n        if (!this.useuuid) {\n            this.nodeId++;\n        }\n\n        return newNodeId;\n    }\n\n    // addNodeImport(dataNode, precanvas) {\n    //     const parent = document.createElement('div');\n    //     parent.classList.add(\"parent-node\");\n\n    //     const node = document.createElement('div');\n    //     node.innerHTML = \"\";\n    //     node.setAttribute(\"id\", \"node-\" + dataNode.id);\n    //     node.classList.add(\"drawflow-node\");\n    //     if (dataNode.class != '') {\n    //         node.classList.add(...dataNode.class.split(' '));\n    //     }\n\n    //     const inputs = document.createElement('div');\n    //     inputs.classList.add(\"inputs\");\n\n    //     const outputs = document.createElement('div');\n    //     outputs.classList.add(\"outputs\");\n\n    //     Object.keys(dataNode.inputs).map(function(input_item, index) {\n    //         const input = document.createElement('div');\n    //         input.classList.add(\"input\");\n    //         input.classList.add(input_item);\n    //         inputs.appendChild(input);\n    //         Object.keys(dataNode.inputs[input_item].connections).map(function(output_item, index) {\n\n    //             var connection = document.createElementNS('http://www.w3.org/2000/svg', \"svg\");\n    //             var path = document.createElementNS('http://www.w3.org/2000/svg', \"path\");\n    //             path.classList.add(\"main-path\");\n    //             path.setAttributeNS(null, 'd', '');\n    //             // path.innerHTML = 'a';\n    //             connection.classList.add(\"connection\");\n    //             connection.classList.add(\"node_in_node-\" + dataNode.id);\n    //             connection.classList.add(\"node_out_node-\" + dataNode.inputs[input_item].connections[output_item].node);\n    //             connection.classList.add(dataNode.inputs[input_item].connections[output_item].input);\n    //             connection.classList.add(input_item);\n\n    //             connection.appendChild(path);\n    //             precanvas.appendChild(connection);\n\n    //         });\n    //     });\n\n    //     for (var x = 0; x < Object.keys(dataNode.outputs).length; x++) {\n    //         const output = document.createElement('div');\n    //         output.classList.add(\"output\");\n    //         output.classList.add(\"output_\" + (x + 1));\n    //         outputs.appendChild(output);\n    //     }\n\n    //     const content = document.createElement('div');\n    //     content.classList.add(\"node-content\");\n\n    //     if (dataNode.typenode === false) {\n    //         content.innerHTML = dataNode.html;\n    //     } else if (dataNode.typenode === true) {\n    //         content.appendChild(this.noderegister[dataNode.html].html.cloneNode(true));\n    //     } else {\n    //         if (parseInt(this.render.version) === 3) {\n    //             //Vue 3\n    //             let wrapper = this.render.h(this.noderegister[dataNode.html].html, this.noderegister[dataNode.html].props, this.noderegister[dataNode.html].options);\n    //             wrapper.appContext = this.parent;\n    //             this.render.render(wrapper, content);\n\n    //         } else {\n    //             //Vue 2\n    //             let wrapper = new this.render({\n    //                 parent: this.parent,\n    //                 render: h => h(this.noderegister[dataNode.html].html, {\n    //                     props: this.noderegister[dataNode.html].props\n    //                 }),\n    //                 ...this.noderegister[dataNode.html].options\n    //             }).$mount()\n    //             content.appendChild(wrapper.$el);\n    //         }\n    //     }\n\n    //     Object.entries(dataNode.data).forEach(function(key, value) {\n    //         if (typeof key[1] === \"object\") {\n    //             insertObjectkeys(null, key[0], key[0]);\n    //         } else {\n    //             var elems = content.querySelectorAll('[data-' + key[0] + ']');\n    //             for (var i = 0; i < elems.length; i++) {\n    //                 elems[i].value = key[1];\n    //                 if (elems[i].isContentEditable) {\n    //                     elems[i].innerText = key[1];\n    //                 }\n    //             }\n    //         }\n    //     })\n\n    //     function insertObjectkeys(object, name, completname) {\n    //         if (object === null) {\n    //             var object = dataNode.data[name];\n    //         } else {\n    //             var object = object[name]\n    //         }\n    //         if (object !== null) {\n    //             Object.entries(object).forEach(function(key, value) {\n    //                 if (typeof key[1] === \"object\") {\n    //                     insertObjectkeys(object, key[0], completname + '-' + key[0]);\n    //                 } else {\n    //                     var elems = content.querySelectorAll('[data-' + completname + '-' + key[0] + ']');\n    //                     for (var i = 0; i < elems.length; i++) {\n    //                         elems[i].value = key[1];\n    //                         if (elems[i].isContentEditable) {\n    //                             elems[i].innerText = key[1];\n    //                         }\n    //                     }\n    //                 }\n    //             });\n    //         }\n    //     }\n    //     node.appendChild(inputs);\n    //     node.appendChild(content);\n    //     node.appendChild(outputs);\n    //     node.style.top = dataNode.pos_y + \"px\";\n    //     node.style.left = dataNode.pos_x + \"px\";\n    //     parent.appendChild(node);\n    //     this.precanvas.appendChild(parent);\n    // }\n\n    addRerouteImport(dataNode) {\n        const reroute_width = this.reroute_width\n        const reroute_fix_curvature = this.reroute_fix_curvature\n        const container = this.container;\n        Object.keys(dataNode.outputs).map(function(output_item, index) {\n            Object.keys(dataNode.outputs[output_item].connections).map(function(input_item, index) {\n                const points = dataNode.outputs[output_item].connections[input_item].points\n                if (points !== undefined) {\n\n                    points.forEach((item, i) => {\n                        const input_id = dataNode.outputs[output_item].connections[input_item].node;\n                        const input_class = dataNode.outputs[output_item].connections[input_item].output;\n                        const ele = container.querySelector('.connection.node_in_node-' + input_id + '.node_out_node-' + dataNode.id + '.' + output_item + '.' + input_class);\n\n                        if (reroute_fix_curvature) {\n                            if (i === 0) {\n                                for (var z = 0; z < points.length; z++) {\n                                    var path = document.createElementNS('http://www.w3.org/2000/svg', \"path\");\n                                    path.classList.add(\"main-path\");\n                                    path.setAttributeNS(null, 'd', '');\n                                    ele.appendChild(path);\n\n                                }\n                            }\n                        }\n\n                        const point = document.createElementNS('http://www.w3.org/2000/svg', \"circle\");\n                        point.classList.add(\"point\");\n                        var pos_x = item.pos_x;\n                        var pos_y = item.pos_y;\n\n                        point.setAttributeNS(null, 'cx', pos_x);\n                        point.setAttributeNS(null, 'cy', pos_y);\n                        point.setAttributeNS(null, 'r', reroute_width);\n\n                        ele.appendChild(point);\n                    });\n                };\n            });\n        });\n    }\n\n    updateNodeValue(event) {\n        var attr = event.target.attributes\n        for (var i = 0; i < attr.length; i++) {\n            if (attr[i].nodeName.startsWith('data-')) {\n                var keys = attr[i].nodeName.slice(3).split(\"-\");\n                var target = this.drawflow.drawflow[this.module].data[event.target.closest(\".node-content\").parentElement.id.slice(5)].data;\n                for (var index = 0; index < keys.length - 1; index += 1) {\n                    if (target[keys[index]] == null) {\n                        target[keys[index]] = {};\n                    }\n                    target = target[keys[index]];\n                }\n                target[keys[keys.length - 1]] = event.target.value;\n                if (event.target.isContentEditable) {\n                    target[keys[keys.length - 1]] = event.target.innerText;\n                }\n                this.dispatch('nodeDataChanged', event.target.closest(\".node-content\").parentElement.id.slice(5));\n            }\n        }\n    }\n\n    updateNodeDataFromId(id, data) {\n        var moduleName = this.getModuleFromNodeId(id)\n        this.drawflow.drawflow[moduleName].data[id].data = data;\n        if (this.module === moduleName) {\n            const content = this.container.querySelector('#node-' + id);\n\n            Object.entries(data).forEach(function(key, value) {\n                if (typeof key[1] === \"object\") {\n                    insertObjectkeys(null, key[0], key[0]);\n                } else {\n                    var elems = content.querySelectorAll('[data-' + key[0] + ']');\n                    for (var i = 0; i < elems.length; i++) {\n                        elems[i].value = key[1];\n                        if (elems[i].isContentEditable) {\n                            elems[i].innerText = key[1];\n                        }\n                    }\n                }\n            })\n\n            function insertObjectkeys(object, name, completname) {\n                if (object === null) {\n                    var object = data[name];\n                } else {\n                    var object = object[name]\n                }\n                if (object !== null) {\n                    Object.entries(object).forEach(function(key, value) {\n                        if (typeof key[1] === \"object\") {\n                            insertObjectkeys(object, key[0], completname + '-' + key[0]);\n                        } else {\n                            var elems = content.querySelectorAll('[data-' + completname + '-' + key[0] + ']');\n                            for (var i = 0; i < elems.length; i++) {\n                                elems[i].value = key[1];\n                                if (elems[i].isContentEditable) {\n                                    elems[i].innerText = key[1];\n                                }\n                            }\n                        }\n                    });\n                }\n            }\n\n        }\n    }\n\n    removeNodeId(id) {\n        this.removeConnectionNodeId(id);\n        var moduleName = this.getModuleFromNodeId(id.slice(5))\n        if (this.module === moduleName) {\n            this.container.querySelector(`#${id}`).remove();\n        }\n        delete this.drawflow.drawflow[moduleName].data[id.slice(5)];\n        this.dispatch('nodeRemoved', id.slice(5));\n    }\n\n    removeConnection() {\n        if (this.connection_selected != null) {\n            var listclass = this.connection_selected.parentElement.classList;\n            this.connection_selected.parentElement.remove();\n            //console.log(listclass);\n            var index_out = this.drawflow.drawflow[this.module].data[listclass[2].slice(14)].outputs[listclass[3]].connections.findIndex(function(item, i) {\n                return item.node === listclass[1].slice(13) && item.output === listclass[4]\n            });\n            this.drawflow.drawflow[this.module].data[listclass[2].slice(14)].outputs[listclass[3]].connections.splice(index_out, 1);\n\n            var index_in = this.drawflow.drawflow[this.module].data[listclass[1].slice(13)].inputs[listclass[4]].connections.findIndex(function(item, i) {\n                return item.node === listclass[2].slice(14) && item.input === listclass[3]\n            });\n            this.drawflow.drawflow[this.module].data[listclass[1].slice(13)].inputs[listclass[4]].connections.splice(index_in, 1);\n            this.dispatch('connectionRemoved', {\n                output_id: listclass[2].slice(14),\n                input_id: listclass[1].slice(13),\n                output_class: listclass[3],\n                input_class: listclass[4]\n            });\n            this.connection_selected = null;\n        }\n    }\n\n    removeSingleConnection(id_output, id_input, output_class, input_class) {\n        var nodeOneModule = this.getModuleFromNodeId(id_output);\n        var nodeTwoModule = this.getModuleFromNodeId(id_input);\n        if (nodeOneModule === nodeTwoModule) {\n            // Check nodes in same module.\n\n            // Check connection exist\n            var exists = this.drawflow.drawflow[nodeOneModule].data[id_output].outputs[output_class].connections.findIndex(function(item, i) {\n                return item.node == id_input && item.output === input_class\n            });\n            if (exists > -1) {\n\n                if (this.module === nodeOneModule) {\n                    // In same module with view.\n                    this.container.querySelector('.connection.node_in_node-' + id_input + '.node_out_node-' + id_output + '.' + output_class + '.' + input_class).remove();\n                }\n\n                var index_out = this.drawflow.drawflow[nodeOneModule].data[id_output].outputs[output_class].connections.findIndex(function(item, i) {\n                    return item.node == id_input && item.output === input_class\n                });\n                this.drawflow.drawflow[nodeOneModule].data[id_output].outputs[output_class].connections.splice(index_out, 1);\n\n                var index_in = this.drawflow.drawflow[nodeOneModule].data[id_input].inputs[input_class].connections.findIndex(function(item, i) {\n                    return item.node == id_output && item.input === output_class\n                });\n                this.drawflow.drawflow[nodeOneModule].data[id_input].inputs[input_class].connections.splice(index_in, 1);\n\n                this.dispatch('connectionRemoved', {\n                    output_id: id_output,\n                    input_id: id_input,\n                    output_class: output_class,\n                    input_class: input_class\n                });\n                return true;\n\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    removeConnectionNodeId(id) {\n        const idSearchIn = 'node_in_' + id;\n        const idSearchOut = 'node_out_' + id;\n\n        const elemsOut = this.container.querySelectorAll(`.${idSearchOut}`);\n        for (var i = elemsOut.length - 1; i >= 0; i--) {\n            var listclass = elemsOut[i].classList;\n\n            var index_in = this.drawflow.drawflow[this.module].data[listclass[1].slice(13)].inputs[listclass[4]].connections.findIndex(function(item, i) {\n                return item.node === listclass[2].slice(14) && item.input === listclass[3]\n            });\n            this.drawflow.drawflow[this.module].data[listclass[1].slice(13)].inputs[listclass[4]].connections.splice(index_in, 1);\n\n            var index_out = this.drawflow.drawflow[this.module].data[listclass[2].slice(14)].outputs[listclass[3]].connections.findIndex(function(item, i) {\n                return item.node === listclass[1].slice(13) && item.output === listclass[4]\n            });\n            this.drawflow.drawflow[this.module].data[listclass[2].slice(14)].outputs[listclass[3]].connections.splice(index_out, 1);\n\n            elemsOut[i].remove();\n\n            this.dispatch('connectionRemoved', {\n                output_id: listclass[2].slice(14),\n                input_id: listclass[1].slice(13),\n                output_class: listclass[3],\n                input_class: listclass[4]\n            });\n        }\n\n        const elemsIn = this.container.querySelectorAll(`.${idSearchIn}`);\n        for (var i = elemsIn.length - 1; i >= 0; i--) {\n\n            var listclass = elemsIn[i].classList;\n\n            var index_out = this.drawflow.drawflow[this.module].data[listclass[2].slice(14)].outputs[listclass[3]].connections.findIndex(function(item, i) {\n                return item.node === listclass[1].slice(13) && item.output === listclass[4]\n            });\n            this.drawflow.drawflow[this.module].data[listclass[2].slice(14)].outputs[listclass[3]].connections.splice(index_out, 1);\n\n            var index_in = this.drawflow.drawflow[this.module].data[listclass[1].slice(13)].inputs[listclass[4]].connections.findIndex(function(item, i) {\n                return item.node === listclass[2].slice(14) && item.input === listclass[3]\n            });\n            this.drawflow.drawflow[this.module].data[listclass[1].slice(13)].inputs[listclass[4]].connections.splice(index_in, 1);\n\n            elemsIn[i].remove();\n\n            this.dispatch('connectionRemoved', {\n                output_id: listclass[2].slice(14),\n                input_id: listclass[1].slice(13),\n                output_class: listclass[3],\n                input_class: listclass[4]\n            });\n        }\n    }\n\n    getModuleFromNodeId(id) {\n        var nameModule;\n        const editor = this.drawflow.drawflow\n        Object.keys(editor).map(function(moduleName, index) {\n            Object.keys(editor[moduleName].data).map(function(node, index2) {\n                if (node == id) {\n                    nameModule = moduleName;\n                }\n            })\n        });\n        return nameModule;\n    }\n\n    addModule(name) {\n        this.drawflow.drawflow[name] = {\n            \"data\": {}\n        };\n        this.dispatch('moduleCreated', name);\n    }\n    changeModule(name) {\n        this.dispatch('moduleChanged', name);\n        this.module = name;\n        this.precanvas.innerHTML = \"\";\n        this.canvas_x = 0;\n        this.canvas_y = 0;\n        this.pos_x = 0;\n        this.pos_y = 0;\n        this.mouse_x = 0;\n        this.mouse_y = 0;\n        this.zoom = 1;\n        this.zoom_last_value = 1;\n        this.precanvas.style.transform = '';\n        this.import(this.drawflow, false);\n    }\n\n    removeModule(name) {\n        if (this.module === name) {\n            this.changeModule('Home');\n        }\n        delete this.drawflow.drawflow[name];\n        this.dispatch('moduleRemoved', name);\n    }\n\n    clearModuleSelected() {\n        this.precanvas.innerHTML = \"\";\n        this.drawflow.drawflow[this.module] = {\n            \"data\": {}\n        };\n    }\n\n    clear() {\n        this.precanvas.innerHTML = \"\";\n        this.drawflow = {\n            \"drawflow\": {\n                \"Home\": {\n                    \"data\": {}\n                }\n            }\n        };\n    }\n    export() {\n        const dataExport = JSON.parse(JSON.stringify(this.drawflow));\n        this.dispatch('export', dataExport);\n        return dataExport;\n    }\n\n    import(data, notifi = true) {\n        this.clear();\n        this.drawflow = JSON.parse(JSON.stringify(data));\n        this.load();\n        if (notifi) {\n            this.dispatch('import', 'import');\n        }\n    }\n\n    /* Events */\n    on(event, callback) {\n        // Check if the callback is not a function\n        if (typeof callback !== 'function') {\n            console.error(`The listener callback must be a function, the given type is ${typeof callback}`);\n            return false;\n        }\n        // Check if the event is not a string\n        if (typeof event !== 'string') {\n            console.error(`The event name must be a string, the given type is ${typeof event}`);\n            return false;\n        }\n        // Check if this event not exists\n        if (this.events[event] === undefined) {\n            this.events[event] = {\n                listeners: []\n            }\n        }\n        this.events[event].listeners.push(callback);\n    }\n\n    removeListener(event, callback) {\n        // Check if this event not exists\n\n        if (!this.events[event]) return false\n\n        const listeners = this.events[event].listeners\n        const listenerIndex = listeners.indexOf(callback)\n        const hasListener = listenerIndex > -1\n        if (hasListener) listeners.splice(listenerIndex, 1)\n    }\n\n    dispatch(event, details) {\n        // Check if this event not exists\n        if (this.events[event] === undefined) {\n            // console.error(`This event: ${event} does not exist`);\n            return false;\n        }\n        this.events[event].listeners.forEach((listener) => {\n            listener(details);\n        });\n    }\n\n    getUuid() {\n        // http://www.ietf.org/rfc/rfc4122.txt\n        var s = [];\n        var hexDigits = \"0123456789abcdef\";\n        for (var i = 0; i < 36; i++) {\n            s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);\n        }\n        s[14] = \"4\"; // bits 12-15 of the time_hi_and_version field to 0010\n        s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01\n        s[8] = s[13] = s[18] = s[23] = \"-\";\n\n        var uuid = s.join(\"\");\n        return uuid;\n    }\n}\n\n//# sourceURL=webpack://Drawflow/./src/drawflow.js?");

/***/ })

/******/ })["default"];
});